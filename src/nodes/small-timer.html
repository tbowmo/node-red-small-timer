<script type="text/html" data-help-name="smalltimer">
    <p>Timing node with sunset, sunrise, dusk, dawn etc possibilities</p>
    <h3>Details</h3>
    <p><b>Smalltimer</b> is probably not the ultimate Node-Red timing node, sending messages for start and end conditions at any time, day, month or special day.</p>
	<p>In the simplest case, Smalltimer requires no input and you need only to consider the first output. But Smalltimer can be much more.</p>

    <h3>Outputs</h3>
        <dl class="message-properties">
            <dt>payload <span class="property-type">string</span></dt>
            <dd>This is set to the value of the onMsg or offMsg properties in the configuration (depending on state)</dd>
            <dt>topic</dt>
            <dd>Topic set in the configuration properties</dd>
            <dt>state</dt>
            <dd>Will be one of : `on`, `off`, or `auto`</dd>
        </dl>
	<h3>Inputs</h3>
    <p>
        The input can be used as an override by simply sending a text or numeric message as payload. Valid (case-insensitive) messages passed in via msg.payload include:
    </p>
        <dl class="message-properties">
            <dt class="optional">payload <span class="property-type">string as specified</span></dt>
            <dd>payload can contain one of the following values
                <ul>
                    <li>1 (or on)</li>
                    <li>0 (or off)</li>
                    <li>toggle</li>
                    <li>auto (or default)</li>
                    <li>manual</li>
                    <li>sync</li>
                    <li>stop</li>
                </ul>
            </dd>
            <dt class="optional">away <span class="property-type">string</span></dt>
            <dd>
                the string on this property specifies how many minutes / hours / days you are away, which disables the node for the amount<br/>
                for example if you want to momentarily disable the automation for 10 hours, you specify a value of 10h, likewise if you want 10 days, you specify 10d
            </dd>
        </dl>
    <p>
        NOTE! if input contains non decodable properties / strings, the input will be ignored, and an error will be emitted to Node-Red
    </p>
    <p>For more advanced uses a set of special message properties can be used to send additional data</p>

    <h3>Manual Overrides</h3>
    <p>
        If the payload property in a message is set to either 0 (or off) or 1 (or on), the state is turned either off or on. The state will be kept until either of the following conditions is met<br/>
        <ul>
            <li>24 hours has elapsed</li>
            <li>a new output state is set as a result of the on/off times configured in the node</li>
        </ul>
    </p>
    <p>if the message payload is set to the string "auto" or "default" then the node will switch back to the configured state, if it was forced to be on/off</p>
	<p>The first two override messages (1/0) time-out after 24 hours (1440 minutes, user-settable) OR at the next change of schedule. If you have also selected "manual" - the outputs will NOT revert back at change of schedule (auto to reset).</p>
    <p>The schedule can be paused by the interface tick box or by the "manual" command (use the "auto" command to return to normal)</p>
    <p>The on_override and off_override fields can be used to supercede the set inputs for on and off times (in minutes) - "on_override 20:15" for example (without the quotes) for 8:15pm. These settings are volatile, i.e. not restored when Node-Red is restarted. It may take up to a minute for these controls to take effect. Use for example "on_override" with no arguments to set the auto-on time back to normal.</p>
	<p>Manual UTC is optional offset (hrs) in case you have a special reason not to have the right time on your computer! Normally 0.</p>
    <h3>Status Display</h3>
   <p>Remember, the status display only updates once per minute unless in timer mode (seconds). If you have Smalltimer set to OFF you should see a black "No action today" message - if you use manual inject to override - it may take up to a minute for this message to re-appear.</p>
   <h3>Dusk, Dawn and More</h3>
	<p>The Dawn and Dusk offsets can be both positive (+ve) for minutes later or negative (-ve) for minutes earlier.</p>

  <h3>Special Days</h3>
   These include special days (i.e. 25/12) and special weekdays (i.e. first Tuesday of the month) and as of v2.0.0 these can be included or excluded.
   You can if you wish (from v2.3.0 onwards) for example merely turn on Smalltimer one day every month of the year by turning off ALL months and using the 12 special days.
   For those occasions where "alternative days" are required there are checkbox options to BAN output on even and/or odd days of the month.
</script>

<script type="text/html" data-template-name="smalltimer">
    <div class="form-row">
        <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
        <input type="text" id="node-input-name" placeholder="Name">
    </div>
    <div class="form-row">
        <label for="node-input-position"><i class="fa fa-map-marker"></i> Position</label>
        <input type="text" id="node-input-position" placeholder="Position">
    </div>
    <div class="form-row">
        <label><i class="fa fa-cog"></i> Options</label>
        <div style="display:inline-block;" class="small-timer-options">
            <div>
                <label><input type="checkbox" id="node-input-repeat"> Repeat</label>
                <label><input type="checkbox" id="node-input-injectOnStartup"> Inject on startup</label>
            </div>
            <div>
                <label><input type="checkbox" id="node-input-wrapMidnight" > Wrap midnight</label>
                <label><input type="checkbox" id="node-input-debugEnable" > Debug enable</label>
            </div>
        </div>
    </div>

    <div class="form-tips">
        <b>Tip</b> Specify offset as a positive or negative number of minutes (120 for 2 hours)
    </div>
    <div class="form-row">
        <label for="node-input-startTime"><i class="fa fa-clock-o"></i> On time</label>
        <input type="text" id="node-input-startTime" class="hidden">
        <select style="width:100px" id="node-input-startTime-select">
        </select>
        <span for="node-input-startOffset" style="margin-left:20px">Offset</span>
        <input  style="width:80px" type="text" id="node-input-startOffset" placeholder="0">
    </div>
    <div class="form-row">
        <label  for="node-input-endTime"><i class="fa fa-clock-o"></i> Off time</label>
        <input type="text" id="node-input-endTime">
        <select style="width:100px" id="node-input-endTime-select">
        </select>
        <span for="node-input-end Offset" style="margin-left:20px">Offset</span>
        <input  style="width:80px" type="text" id="node-input-endOffset" placeholder="0">
    </div>
    <div class="form-row">
        <label>Override timeout</label>
        <div style="display:inline-block" class="small-timer-overrides">
            <label for="node-input-onTimeout"> On</label>
            <input type="text" id="node-input-onTimeout" placeholder="1440">
            <label for="node-input-offTimeout"> Off</label>
            <input type="text" id="node-input-offTimeout" placeholder="1440">
        </div>
    </div>
    <div class="form-row">
        <label for="node-input-name"><i class="fa fa-tasks"></i> Topic</label>
        <input type="text" id="node-input-topic" placeholder="Topic">
    </div>
    <div class="form-row">
        <label for="node-input-onMsg"><i class="fa fa-sign-out"></i> On message</label>
        <input type="text" id="node-input-onMsg">
        <input type="hidden" id="node-input-onMsgType">
    </div>
    <div class="form-row">
        <label for="node-input-offMsg"><i class="fa fa-sign-out"></i> Off message</label>
        <input  type="text" id="node-input-offMsg">
        <input type="hidden" id="node-input-offMsgType">
    </div>
    <div class="form-row node-input-rules-container-row">
        <label style="width: 400px;">Rules</label>
        <ol id="node-input-rules-container"></ol>
    </div>
    <div class="form-tips">
        If day exceeds the number of days available in the specified month, it is considered to be the last day of the month.<br/>
    </div>
    <input id="node-input-outputs" type="hidden" value="1">
</script>
<style>
    .small-timer-overrides label {
        width: 40px !important;
    }

    .small-timer-overrides input {
        width: 80px !important;
        margin-right: 8px;
    }

    .small-timer-options label {
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        vertical-align: baseline;
        width: 120px !important;
        white-space: nowrap;
    }

    .small-timer-options input {
        width: auto !important;
        vertical-align: baseline !important;
    }

    .form-tips {
        margin-bottom: 8px;
    }
</style>

<script type="text/javascript">
    (function () {
        const monthNames = [
            { value: 0, label: 'All' },
            { value: 1, label: "January" },
            { value: 2, label: "February" },
            { value: 3, label: "March" },
            { value: 4, label: "April" },
            { value: 5, label: "May" },
            { value: 6, label: "June" },
            { value: 7, label: "July" },
            { value: 8, label: "August" },
            { value: 9, label: "September" },
            { value: 10, label: "October" },
            { value: 11, label: "November" },
            { value: 12, label: "December" }
        ];

        const weekDays = [
            { value: 100, label: 'Sunday' },
            { value: 101, label: 'Monday' },
            { value: 102, label: 'Tuesday' },
            { value: 103, label: 'Wednesday' },
            { value: 104, label: 'Thursday' },
            { value: 105, label: 'Friday' },
            { value: 106, label: 'Saturday' },
        ]

        let dayNumbers = Array.apply(null, { length: 31 }).map(Number.call, Number).map((item) => ({ label: item + 1, value: item + 1 }));
        dayNumbers.unshift({ label: 'All', value: 0 });

        dayNumbers = [
            ...dayNumbers,
            ...weekDays,
        ]

        const ruleType = [
            { value: 'include', label: '==' },
            { value: 'exclude', label: '<>' }
        ]

        function exportRule(monthDay) {
            var type = monthDay?.find(".typeSelect").val();
            var month = monthDay?.find(".monthSelect").val();
            var day = monthDay?.find(".daySelect").val();
            return { type, month, day };
        }

        RED.nodes.registerType('smalltimer', {
            category: 'advanced-input',
            color: "#88dd22",
            inputLabels: "Optional overrides",
            outputLabels: ["status message", "debug output"],
            defaults: {
                name: { value: 'Small timer', required: true },
                position: { value: "", type: "position" },
                startTime: { value: 5001, required: true },
                endTime: { value: 1425, required: true },
                startOffset: { value: 0, required: true },
                endOffset: { value: 0, required: true },

                topic: { value: '' },

                onMsg: { value: '1' },
                onMsgType: { value: 'str' },
                onTimeout: { value: 1440, required: true },

                offMsg: { value: '0' },
                offMsgType: { value: 'str' },
                offTimeout: { value: 1440, required: true },

                rules: { value: [{ type: 'include', month: 0, day: 0 }] },

                repeat: { value: false, required: true },
                wrapMidnight: { value: true },
                injectOnStartup: { value: false, required: true },

                debugEnable: {value: false},
                // legacy prop
                timeout: { value: 1440 },
                outputs: {value: 1}
            },
            icon: "timer.png",
            inputs: 1,
            outputs: 1,
            label: function () {
                return this.name || this.prefix;
            },
            labelStyle: function () {
                return this.name ? "node_label_italic" : "";
            },
            oneditprepare: function () {
                var node = this

                if (node.onTimeout === undefined) {
                    node.onTimeout = node.timeout
                    $('#node-input-onTimeout').val(node.timeout)
                }
                if (node.offTimeout === undefined) {
                    node.offTimeout = node.timeout
                    $('#node-input-offTimeout').val(node.timeout)
                }

                $("#node-input-onMsg").typedInput({
                    typeField: "#node-input-onMsgType",
                    default: 'str',
                    types: ["str", "num", "bool", "json"],
                })
                $("#node-input-offMsg").typedInput({
                    typeField: "#node-input-offMsgType",
                    default: 'str',
                    types: ["str", "num", "bool", "json"],
                })

                generateTimes('#node-input-startTime', false)
                generateTimes('#node-input-endTime', true)

                $("#node-input-rules-container").css('min-height', '150px').css('min-width', '450px').editableList({
                    header: $("<div>").append($.parseHTML(`
                    <div style='width:20%; display: inline-grid'>Type</div>
                    <div style='width:30%; display: inline-grid'>Month</div>
                    <div style='display: inline-grid'>Day of month/week</div>
                `)),
                    scrollOnAdd: true,
                    sortable: true,
                    removable: true,
                    addButton: 'Add rule',
                    addItem: function (container, i, opt) {
                        if (!opt.hasOwnProperty('r')) {
                            opt.r = {};
                            if (i > 0) {
                                var lastRule = $("#node-input-rules-container").editableList('getItemAt', i - 1);
                                var exported = exportRule(lastRule.element);
                                opt.r.month = exported.month;
                                opt.r.day = exported.day;
                                opt.r.type = exported.type;
                                // We could copy the value over as well and preselect it (see the 'activeElement' code below)
                                // But not sure that feels right. Is copying over the last value 'expected' behaviour?
                                // It would make sense for an explicit 'copy' action, but not sure where the copy button would
                                // go for each rule without being wasted space for most users.
                                // opt.r.v = exportedRule.v;
                            }
                        }

                        opt.element = container;
                        var rule = opt.r;
                        if (!rule.hasOwnProperty('month')) {
                            rule.month = 0;
                        }
                        if (!rule.hasOwnProperty('type')) {
                            rule.type = 'include';
                        }
                        if (!rule.hasOwnProperty('day')) {
                            rule.day = 0;
                        }
                        if (!opt.hasOwnProperty('i')) {
                            opt._i = Math.floor((0x99999 - 0x10000) * Math.random()).toString();
                        }

                        container.css({
                            overflow: 'hidden',
                            whiteSpace: 'nowrap',
                            display: "flex",
                            "align-items": "center"
                        });

                        const row = $('<div></div>', { style: "flex-grow:1" }).appendTo(container);
                        const typeSelect = $('<select/>', { style: "width:20%; margin-left:5px" }).addClass('typeSelect').appendTo(row);
                        const monthSelect = $('<select/>', { style: "width:30%; margin-left:5px" }).addClass('monthSelect').appendTo(row);
                        const daySelect = $('<select/>', { style: "width:40%; margin-left:5px" }).addClass('daySelect').appendTo(row);

                        ruleType.forEach((r) => {
                            typeSelect.append($("<option></option>").val(r.value).text(r.label));
                        })
                        monthNames.forEach((r) => {
                            monthSelect.append($("<option></option>").val(r.value).text(r.label));
                        })
                        dayNumbers.forEach((r) => {
                            daySelect.append($("<option></option>").val(r.value).text(r.label));
                        })

                        monthSelect.val(rule.month);
                        typeSelect.val(rule.type);
                        daySelect.val(rule.day);

                    },
                    removeItem: function (opt) {
                        var rules = $("#node-input-rule-container").editableList('items');
                        rules.each(function (i) {
                            $(this).find(".node-input-rule-index").html(i + 1);
                        });
                    },
                });

                this.rules.forEach((rule, i) => {
                    $("#node-input-rules-container").editableList('addItem', { r: rule, i: i });
                })
                $('#node-input-debugEnable').click(function() {
                    $('#node-input-outputs').val(this.checked ? 2 : 1)
                })
            },
            oneditsave: function () {
                var rules = $("#node-input-rules-container").editableList('sort').editableList('items');
                var node = this;
                node.rules = [];
                rules.each(function (i) {
                    node.rules.push(exportRule($(this)));
                });
                $('#node-input-startTime').val($('#node-input-startTime-select').val());
                $('#node-input-endTime').val($('#node-input-endTime-select').val());
            }
        })

        function generateTimes(selectId, endTime = false) {
            $(selectId).hide()
            let html = ''
            const pad = (n) => `00${n.toFixed(0)}`.substr(-2)
            for (let time = 0; time < 1439; time += 15) {
                const minutes = time % 60
                const hour = Math.floor(time / 60)
                html = html + `<option value=${time}>${pad(hour)}:${pad(minutes)}</option>`
            }

            html = html + `
        <option value="1439">Day End</option>
        <option value="5000">Dawn</option>
        <option value="5001">Dusk</option>
        <option value="5002">Solarnoon</option>
        <option value="5003">Sunrise</option>
        <option value="5004">Sunset</option>
        <option value="5005">Night</option>
        <option value="5006">Night end</option>
        <option value="5007">Moonrise</option>
        <option value="5008">Moonset</option>
        `
            if (endTime) {
                html = html + `
            <option value="10001">1 minute</option>
            <option value="10002">2 minutes</option>
            <option value="10005">5 minutes</option>
            <option value="10010">10 minutes</option>
            <option value="10015">15 minutes</option>
            <option value="10030">30 minutes</option>
            <option value="10060">60 minutes</option>
            <option value="10090">90 minutes</option>
            <option value="10120">120 minutes</option>
            `
            }
            $(`${selectId}-select`).html(html);
            $(`${selectId}-select`).val($(selectId).val());
        }
    })()
</script>
